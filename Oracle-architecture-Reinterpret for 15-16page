# Oracle In-Memory Lifecycle & Management Internals

> **Note:** A detailed look at IMCUs, Metadata mapping, the Expression Statistics Store (ESS), and the synchronization mechanisms between the Buffer Cache and the In-Memory Area.

---

## 1. Enabling In-Memory: Objects and Tablespaces

To populate objects into the IM Column Store, the `INMEMORY` attribute must be enabled during object creation or alteration. This applies to Tables, Partitions, and Tablespaces.

**Concept: Tablespace**
* **My Understanding:** A "Logical Hard Drive Partition" (or a giant folder).
* **Technical Definition:** A logical storage container that groups related logical structures (tables, indexes) together. Enabling `INMEMORY` at the tablespace level sets the default attribute for all new tables created within it.

---

## 2. IMCU: The Optimized Storage Unit

The IM Column Store uses **Optimized Storage Units** rather than traditional Oracle Data Blocks. This is another "Crown Jewel" technology of Oracle.

* **Traditional Oracle Blocks:** Designed for "Convenience" and general-purpose I/O (Row-major).
* **IMCU (In-Memory Compression Unit):** Designed for extreme speed.
    * **Characteristics:**
        1.  **Read-Only (Immutable):** Since they are never modified in place, they can be aggressively compressed to save memory.
        2.  **Compression:** Specifically optimized for CPU SIMD vector processing (decompression at the speed of hardware).
        3.  **Columnar:** Stores a specific set of columns for a range of rows.

---

## 3. The IMCU and SMU Relationship



Every **IMCU** (Data) maps to a separate **SMU** (Snapshot Metadata Unit).

**The Mapping Logic:**
* **Question:** Can one IMCU map to multiple SMUs, or vice versa?
* **Answer:** It is strictly a **One-to-One Relationship**.
    * **1 IMCU** contains the actual data (compressed columns).
    * **1 SMU** contains the metadata (Transactional Bitmap) for the rows inside that specific IMCU.
* **Granularity:** Whether an IMCU holds 1,000 rows or 1 million rows, it has exactly one corresponding SMU to track the validity of those rows.

---

## 4. ESS (Expression Statistics Store): The "Permanent" Component

I describe the **ESS** as a "Pre-calculation Log."
* **Function:** It records the usage of expressions (e.g., `price * tax`) and stores the results not just in the SGA, but persists them to disk. It serves "the best of both worlds."

**Why is it a "Permanent Component"?**
The documentation highlights that ESS is active even if the In-Memory Column Store is disabled.
* **The Reason:** Even if you haven't bought the In-Memory license yet, the ESS is silently running in the background, analyzing your query patterns. It gathers statistics so that if you *do* enable In-Memory later, the database already knows which calculations are "Hot" and should be optimized as **Virtual Columns**.

---

## 5. Memory Allocation: The Tale of Two Pools

The In-Memory Area is internally subdivided into two distinct pools. This is a relativity problem: "Small" blocks aggregating into a "Large" area.

1.  **The 1MB Data Pool:**
    * **Purpose:** Stores the actual **IMCUs** (Columnar Data).
    * **Why 1MB?** Columnar data is bulky. A traditional 8KB block is too small (like trying to put a sofa in a mailbox). A 1MB "Large Brick" is the optimal granular size for these compression units.

2.  **The 64KB Metadata Pool:**
    * **Purpose:** Stores the **SMUs** (Transactional Metadata).
    * **Why 64KB?** The "instruction manual" (validity bitmap) is thin. Using a 1MB block for metadata would be a massive waste of space.

---

## 6. INMEMORY_SIZE: The "Irreversible" Growth

The `INMEMORY_SIZE` parameter can be dynamically increased, but **cannot be dynamically decreased**.

**The Analogy: "Water under the bridge"**
* **Growing:** Like building an extension on an empty lot next to your house. Easy.
* **Shrinking:**
    * **Scenario:** Data is scattered everywhere (Memory Fragmentation).
    * **The Cost:** To return memory to the OS, the database would have to strictly "Defragment" (move active data from the edge to the center) while the database is running live.
    * **Consequence:** This massive data relocation would cause CPU spikes and a **Performance Avalanche**. Therefore, Oracle forbids hot-shrinking for stability reasons.

---

## 7. Synchronization: Buffer Cache is Truth, IM is Snapshot

This reverses our previous logic about data modification.
* **Buffer Cache (Row Store):** The **Source of Truth**. Modifications happen here.
* **In-Memory Area (Column Store):** A **Read-Only Mirror**.

**The Mechanism:**
When a user updates data (DML):
1.  The data in the **Buffer Cache** becomes the "New Version."
2.  The data in the **IMCU** does *not* change (because it is Read-Only).
3.  Instead, the corresponding row in the IMCU is marked as **"Stale" (Invalid)** via the SMU.
4.  **Concept:** The IM Area is just a fast "Snapshot." If the snapshot expires (too many invalid rows), it must be thrown away and rebuilt.

---

## 8. The Background "Restocking" Workflow

How does data get into memory? It involves a team of processes:

1.  **Server Process:** Handles the user's DML (Insert/Update/Delete). It updates the Buffer Cache and marks rows as stale in the SMU.
2.  **IMCO (In-Memory Coordinator):** The "Manager." It wakes up periodically (e.g., every 2 minutes) to check if any IMCUs are too stale and need refreshing (Repopulation).
3.  **SMCO (Space Management Coordinator):** The "Foreman." It receives orders from IMCO to organize space.
4.  **Wnnn (Worker Processes):** The "Laborers." They do the heavy lifting: reading fresh data from disk/buffer cache and building new IMCUs.

> **Summary:** DML changes write to the Buffer Cache instantly. The In-Memory Area catches up asynchronously via background repopulation.




要将对象添加到 IM 列存储，请在创建或更改对象时启用该对象的 INMEMORY 属性。您可以为以下对象指定此属性：

这里的表空间咱们细细讨论一下，它就是一个“逻辑硬盘分区”（文件夹）。


IM 列存储使用优化的存储单元（而非传统的 Oracle 数据块）来管理数据和元数据。
咱们前面说过，这个列存储对于计算一些业务之类的，这个列是非常快的，这里的优化存储单元同样是Oracle的“引以为傲”的技术。
传统块 (Traditional Oracle Data Blocks)：它设计的初衷就是为了方便。
优化存储单元 (IMCU - In-Memory Compression Unit)：通常会有3个特性：
1.只读 (Read-only)： 因为不准改，所以可以压缩得非常狠（省内存）。
2.因为压缩 (Compressed)： 它是专门为了 CPU 快速扫描设计的格式。
3.列式： 它里面存的是一整列的数据。想怎么快就怎么快。




下面的IMCU和SMU，每个 IMCU 都映射到一个单独的 SMU。
但是我一个IMCU有成千上万个列，也都可以映射到单独SMU吧？
答案很接近，但有些不同，这取决于大小。
IMCU和SMU是一对一的关系。
取决于IMCU的容量，如果IMCU可以装三个，那三个一对应一个SMU。如果100个，那100个IMCU对应一个SMU。



这个ESS我可以称为是计算的一个“提前量”日志，它会写入磁盘，这个用途是，你在每一次计算完的结果放在磁盘里。而且不仅存在SGA里，还存在硬盘里，两全其美。


ESS 独立于 IM 列存储，ESS 是数据库的永久组件，无法禁用。这里我有点懵，它首次在文档里引入了永久组件的概念，我们前面也提到了可选组件，除了可选组件，就全是永久组件。
但这里它为什么特别强调呢？
答案是：告诉你哪怕你没买 In-Memory 的许可证，没开启内存列存储功能，ESS 依然在后台默默地统计你的计算习惯。


内存区域被细分为两个池：一个 1MB 的列式数据池，用于存储实际填充到内存中的列格式数据（IMCU 和 IMEU）；以及一个 64K 的元数据池，用于存储有关填充到 IM 列式存储中的对象的元数据。
这里你能给我说说吗？这个咱们在讨论相对论的问题，这个1mb和64k是类似于我们墙壁的砖头，单个很小，实际上特别大。
数据池 (Data Pool)： 用 1MB 的大格子来装实际的列数据 (IMCU)。为什么要 1MB？因为列式压缩数据通常比较大，用 8KB 的小格子装不下，用 1MB 的“大砖头”刚刚好。

元数据池 (Metadata Pool)： 用 64KB 的小格子来装说明书 (SMU)。说明书很薄，用 1MB 的格子太浪费了。



下面提到了Oracle的INMEMORY_SIZE，只能扩大，不能缩小，为什么？
这有点覆水难收的意思。
你看哈，扩大 (Grow)： 就像你家房子旁边是一片荒地（空闲内存）。你想扩建一个房间，直接去荒地上盖就行了，很简单。
缩小 (Shrink)：

假设你现在的内存区域里，这里存了一点数据，那里存了一点数据（内存碎片）。

如果你想把内存“还给”操作系统，你必须先把这些散落在边缘的数据全部搬家，挤到中间去，腾出一块连续的空地才能还回去。
代价： 在数据库高速运转时，做这种“大搬家”会让 CPU 疯狂空转，导致数据库性能瞬间雪崩。所以 Oracle 选择“为了安全，禁止热缩小”




还有就是内存表转变副本，这里一定要注意，这跟我们之前的完全反过来了。
Buffer Cache (行式)：数据改了，这里是最新的。硬盘是旧的。

In-Memory Area (列式)：是只读镜像。
性质： 它是 Read-Only (只读) 的。
用户改了数据 -> Buffer Cache (行式) 里的数据变了（变成最新的）。
In-Memory Area (列式) 里的旧数据怎么办？它不会立刻变新，它会立刻“失效”。
在 IM 架构里，Buffer Cache 才是真理，In-Memory Area 只是一个为了加速查询而存在的“快照”。 如果快照过期了，就得重新做。


服务器进程响应查询和数据操作语言 (DML) 指令，扫描列式数据并更新空间管理单元 (SMU) 元数据。后台进程将磁盘上的行数据填充到内存管理 (IM) 列式存储中。内存协调器进程 (IMCO) 是一个后台进程，负责启动列式数据的后台填充和重新填充。空间管理协调器进程 (SMCO) 和空间管理工作进程 (Wnnn) 是后台进程，它们代表 IMCO 执行实际的数据填充和重新填充操作。DML 块更改被写入缓冲区缓存。
这一大串在讲“后台补货”流程。






