# Oracle Buffer Cache & Smart Flash Cache: Architecture Deep Dive

> **Note:** Analysis of the data lifecycle, from the Buffer Cache to Smart Flash Cache, and finally to physical storage (HDD/SSD).

---

## 1. The Buffer Cache: The "Protagonist" of Copies

The **Buffer Cache** is a memory area within the SGA used to store copies of data blocks read from data files.

**The Philosophy of "Copies":**
In computer science, the "Copy" is often more important than the "Original."
1.  **Dormant State:** Data on the hard drive is effectively "dead" until accessed.
2.  **Activation:** To read or write, Oracle *must* copy the Block from disk to the **Buffer Cache**.
3.  **The Single Source of Truth:** Once in memory, this "copy" becomes the **Current Version**. Modifications happen here. The version on the disk becomes "Stale" until the `DBWn` (Database Writer) process flushes the changes back.

**Comparison: Deferred Insert vs. Buffer Cache**
* **Deferred Insert Pool:** A "One-way Street" (Ingest only).
* **Buffer Cache:** A "Town Square" (Bi-directional traffic: Read & Write). It optimizes physical I/O by keeping frequently accessed blocks in memory.

---

## 2. Buffer Pools Strategy

### The Default Pool & Block Sizes
* **Standard Block Size:** Usually 8KB. This is defined at database creation and cannot be changed without recreating the database.
* **Non-Standard Pools:** Used for tablespaces with 2KB, 4KB, 16KB, or 32KB block sizes.

### The Keep Pool
* **Purpose:** To pin specified objects in memory to avoid I/O.
* **Logic:** It serves as a VIP area. It prevents "hot data that *should* be in memory" from being accidentally evicted by the standard LRU algorithm due to space pressure in the Default Pool.

---

## 3. The Hierarchy of Speed (Latency)

When data is requested, the lookup order is strictly defined by physics (Speed):

1.  **Buffer Cache (RAM):** **Nanoseconds**. Right next to the CPU.
2.  **Smart Flash Cache (SSD):** **Microseconds**. 100x-1000x slower than RAM.
3.  **Disk Storage (HDD):** **Milliseconds**. 100x slower than Flash.

### RAC & Flash Cache Symmetry
In a **Real Application Clusters (RAC)** environment, the configuration is boolean: either ALL instances have Flash Cache, or NONE do.

**Why? (The Symmetry Rule)**
* **Scenario:** Server A has Flash Cache (Fast); Server B does not (Slow).
* **Consequence:** User experience becomes inconsistent (Performance Asymmetry).
* **Impact:** The internal **Load Balancing** algorithms would fail to distribute work effectively because they assume uniform node capability.

---

## 4. Concurrency: The Multiple LRU List Reality

**Theory vs. Reality:**
* **Conceptually:** One global LRU (Least Recently Used) list is simple.
* **Reality:** Thousands of concurrent processes trying to update one list requires a single **Latch** (Lock). This creates a bottleneck.

**Solution: Working Sets**
Oracle splits the single LRU list into **Multiple LRU Lists (Working Sets)**.
* Process A operates on List 1.
* Process B operates on List 2.
* **Result:** Reduced Latch contention and higher concurrency.

---

## 5. Smart Flash Cache Internals

### The Workflow: "The Sticky Note"
When the Buffer Cache is full, clean blocks must be evicted.
* **Without Flash Cache:** The block is discarded. Next access requires a physical read from HDD.
* **With Flash Cache:** `DBWn` writes the block to the SSD.
* **The Header:** Crucially, Oracle keeps the **Buffer Header** in RAM. This is like a "sticky note" pointing to the SSD location. When requested again, Oracle reads from Flash (Microseconds) instead of HDD.

### The Paradox: Clean vs. Cold vs. Dirty

**Why doesn't the system put "Dirty Data" in Flash Cache?**

1.  **Dirty Data (State):** Modified in memory, not yet written to disk.
    * *Rule:* Must be written to the **Primary Storage (Data Files)** for durability (ACID). Flash Cache is transient; it cannot be responsible for data persistence.
2.  **Clean Data (State):** Identical to the version on disk.
    * *Rule:* Safe to evict or move to Flash Cache.
3.  **Cold Data (Temperature):**
    * **Hot:** Access count is high right now. Keep in RAM.
    * **Cold:** Hasn't been touched in a while (e.g., 10 minutes).
    * **The Strategy:** Even though it is "Cold" (Clean), we move it to Flash Cache instead of discarding it completely. It serves as a "Warm" tier—ready if the data becomes Hot again.

**Summary:**
* **RAM:** Most Hot.
* **Flash:** Warm (Previously Hot, currently Cold, but Clean).
* **HDD:** Cold (The ultimate repository).

---

## 6. The Endgame: Why do HDDs still exist?

**1. Cost (TCO)**
* **All-Flash:** Extremely expensive for Petabyte-scale data.
* **Hybrid:** Using Flash Cache allows us to get "SSD-like performance at HDD prices" for the majority of workloads.

**2. The Counter-Intuitive Speed of HDDs**
* **Random I/O:** HDD is slow (Seek time limits).
* **Sequential I/O:** HDD is **Fast**.
    * Database **Redo Logs** and **RMAN Backups** write sequentially (in a straight line). The drive head doesn't need to jump around, allowing HDDs to saturate their throughput bandwidth.


缓冲区缓存，是系统全局区的内存区域，用于存储从数据文件中读取的数据块的副本。
这里的副本，很有意思，但其实在计算机里，复印件才是主角
1：数据都是平时躺在硬盘里的死文件
2：当你要读写数据时，Oracle 必须把这个数据块（Block）从硬盘完整地复制（Copy） 到内存（Buffer Cache）里。
3：一旦进了内存，这个“副本”就变成了最新版。你修改数据也是改内存里的这个副本。硬盘里那个“原件”反而变成了旧数据（直到 DBWn 把它写回去）。


所有并发连接到数据库实例的用户共享对缓冲区缓存的访问权限。缓冲区缓存的目标是优化物理 I/O，并将频繁访问的数据块保存在缓冲区缓存中，将不常用的数据块写入磁盘。
这里跟之前的延迟插入池很像，区别在于“方向”和“地位”：
延迟插入池 (Deferred Insert Pool)： 是单行道（只进不出）。
缓冲区缓存 (Buffer Cache)： 是大广场（又进又出）。





这个下面还有一个默认池，他说默认8kb，那就是说如果我有很大的预存，你可以分配到2TB，没有上限


这里保留池：用于存放访问频繁但因空间不足而从默认池中过期的数据块。

保留池的目的是将指定的对象保留在内存中，从而避免 I/O 操作。

这两个非但不冲突，而且特别有用，就是为了防止那些“本该常驻内存，却被误伤踢出”的数据被频繁读取 I/O。所以逻辑是自洽的。




非默认缓冲池：适用于使用 2 KB、4 KB、16 KB 和 32 KB 非标准块大小的表空间。
这里是这一部分文档最让我有意思的是，我是拿8kb做标准，其他全部是异类，那我之前的默认池如果改到了4kb，16kb，那么这两个是不是就是标准了？
答案是完全错误，除非你删库重建，否则“默认”是改不了的。



当数据库请求数据时，系统首先在数据库缓冲区缓存中查找。

如果找不到数据，系统则在数据库智能闪存缓存缓冲区中查找。

如果仍然找不到数据，系统才会在磁盘存储中查找。

为什么不先智能闪存缓存缓冲区后数据库缓冲区缓存？
答案是速度问题：
Buffer Cache (RAM 内存)： 速度是 纳秒级。这是最快的，就在 CPU 嘴边。

Flash Cache (SSD 闪存)： 速度是 微秒级。比内存慢 100-1000 倍。

Disk (HDD 机械硬盘)： 速度是 毫秒级。比闪存又慢 100 倍。



在 Oracle 真正应用集群 (RAC) 环境中，您必须在所有实例上配置闪存缓存，或者在所有实例上都不配置。
这里的布尔值的做法是为了什么？
RAC 集群： 是多台服务器一起干活。

场景： 假设服务器 A 有闪存缓存（很快），服务器 B 没有（很慢）。

后果： 用户请求发到 A 就秒开，发到 B 就卡顿。这会导致系统性能忽高忽低，极不稳定。而且 Oracle 内部的负载均衡算法会疯掉，不知道该把任务派给谁。所以强制要求“要装大家一起装”。





从概念上讲，只有一个 LRU，但为了数据并发性，数据库实际上会使用多个 LRU。
这里现实和理论的碰撞是为了什么？
为了解决高并发
理论上： 一个大列表（LRU List）管理所有内存块是最简单的。

现实中： 几千个进程同时要修改这个列表（拿数据、放数据）。如果只有一个列表，就需要一把大锁（Latch），所有进程都要排长队等着操作这个列表。

解决方法： 把一个大列表拆成 N 个小列表。进程 A 去排列表 1，进程 B 去排列表 2。大家互不干扰，并发效率就上来了。



闪存缓存的工作流程：它到底在干啥？

-Buffer 淘汰 -> 写入 Flash -> 保留 Header
当内存满了，会把旧数据丢出去。
如果没有 Flash Cache，这个块就真的被丢掉了。但现在有了 Flash Cache，DBWn 进程会把它写到 SSD (Flash Cache) 里存起来。
数据虽然搬到了 SSD，但 Oracle 会在内存（Buffer Cache）里留一个小纸条（Buffer Header），上面写着：“这个数据在 SSD 的第 X 号位置。”
下次你要查这个数据，Oracle 一看小纸条：“哦，在 SSD 里。” 然后直接去 SSD 读，而不用去慢吞吞的机械硬盘读。


实时应用集群 (RAC) 中闪存缓存缓冲区的一致性维护方式与缓存融合相同。由于闪存缓存是扩展缓存，且直接路径 I/O 完全绕过缓冲区缓存，因此此功能不支持直接路径 I/O。请注意，系统不会……
---直接路径：当你做超大数据导入时，为了快，Oracle 会选择绕过 Buffer Cache，直接往硬盘写。
既然都绕过了内存（Buffer Cache）
那你自然就连带绕过了 Flash Cache

系统不会把“脏数据”放进 Flash Cache：
Oracle 规定：脏数据直接回硬盘，只有干净的（读过的）冷数据才去 Flash Cache 养老。
所以这里我们可能又会有疑问：读过的还叫冷数据吗？

1：干净 vs. 脏 (Clean vs. Dirty) —— 这是“状态”
脏数据 (Dirty)： 数据在内存里被改了（比如余额从 10 块改成了 5 块），但还没写到硬盘里。

处理方式： 这种数据绝对不能随便扔进 Flash Cache（读缓存）。因为它必须优先写回主硬盘（HDD/SSD），确保断电不丢。

干净数据 (Clean)： 内存里的数据和硬盘里的一模一样（只是读上来看看，没改）。


2. 热 vs. 冷 (Hot vs. Cold) —— 这是“热度”
热 (Hot)： 刚被读过，或者这一秒钟有 1 万个人在查它。它应该赖在 RAM (主内存) 里不走。

冷 (Cold)： 它确实被读过（所以它是“读过的”），但是那是 10 分钟前 的事了。现在的 10 分钟内，没人再查它了。

3. 为什么要踢到 Flash Cache？
如果不给 Flash Cache： 这个“变冷”的数据会被直接踢回最慢的 HDD (机械硬盘)。下次万一又有人要查它，还得从 HDD 慢吞吞地捞。

给了 Flash Cache： Oracle 觉得：“虽然它现在冷了，但也许过一会儿又热了呢？” 所以先把它踢到 SSD (Flash Cache) 这种“半热不冷”的地方存着。


总结就是：
RAM (Buffer Cache)： 极贵，极快。 放最热的数据（正在用的）。

SSD (Flash Cache)： 贵，快。 放次热的数据（刚读过的，防备再次查询）。

HDD (Data Files)： 便宜，容量大。 放全量数据（兜底的）。

----------------------------------------------------------------------

这里还有一个终极冷门问题：为什么总会有机械硬盘 (HDD)？

第一肯定是：价格

全闪存 (All-Flash)： 如果全买企业级 SSD，可能要花 1个亿。

混合存储 (Hybrid)： 如果把最近半年的数据放在 SSD，剩下的 4.5 年数据放在 HDD，可能只要 2000万。

当然Oracle聪明在这了，Smart Flash Cache 的存在，就是为了让你“用 HDD 的价格，享受到接近 SSD 的体验”。


还有一反直觉的问题：机械硬盘在写“连续数据”时，其实并不慢。

随机读写：SSD 吊打 HDD（因为 HDD 要移动磁头，物理寻道时间长）。

顺序读写： 比如数据库的 Redo Log（重做日志） 或 RMAN 备份，它们是一条直线一直往下写的。这种时候，HDD 的磁头不用乱跳，速度是可以跑满带宽的。






